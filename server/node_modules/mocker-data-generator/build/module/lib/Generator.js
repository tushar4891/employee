import { __assign, __spreadArray } from "tslib";
import { loopInside, stringToPathOrCall } from './utils';
var Generator = /** @class */ (function () {
    function Generator() {
    }
    Generator.prototype.self = function (cfg) {
        var object = this.object;
        return cfg.eval
            ? eval('object.' + cfg.self)
            : loopInside(this.object, cfg.self);
    };
    Generator.prototype.db = function (cfg) {
        var db = this.DB;
        if (cfg.eval) {
            return eval('db.' + cfg.db);
        }
        else {
            return loopInside(this.DB, cfg.db);
        }
    };
    Generator.prototype.custom = function (cfg) {
        var db = this.DB;
        var object = this.object;
        var re;
        var matches;
        var strFn;
        var generator = cfg.generator;
        if (cfg.run) {
            return cfg.run(generator, cfg.input);
        }
        else if (cfg.eval) {
            return eval('generator.' + cfg.input);
        }
        else {
            return stringToPathOrCall.call(generator, 'generator', generator, cfg.input);
        }
    };
    Generator.prototype.eval = function (cfg) {
        var db = this.DB;
        var object = this.object;
        var generators = this.generators;
        return eval(cfg.eval);
    };
    Generator.prototype.values = function (cfg) {
        var i = Math.floor(cfg.values.length * Math.random());
        return cfg.values[i];
    };
    Generator.prototype.function = function (cfg) {
        var _a;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var object = this.object;
        var db = this.DB;
        var generators = this.generators;
        return (_a = cfg.function).call.apply(_a, __spreadArray([{ object: object, db: db, generators: generators }], args, false));
    };
    Generator.prototype.static = function (cfg) {
        return cfg.static;
    };
    Generator.prototype.incrementalId = function (cfg) {
        var n = 0;
        var db = this.DB;
        if (db[this.name] && db[this.name].length) {
            n = db[this.name].length;
        }
        if (cfg.incrementalId === true) {
            cfg.incrementalId = '0';
        }
        return n + parseInt(cfg.incrementalId, 10);
    };
    Generator.prototype.hasOne = function (cfg) {
        var db = this.DB;
        var entity = null;
        if (cfg.uniqueDB) {
            var dbString = JSON.stringify(cfg.uniqueDB);
            for (var i = 0; i < db[cfg.hasOne].length; i++) {
                var element = db[cfg.hasOne][i];
                element = cfg.get
                    ? cfg.eval
                        ? eval('element.' + cfg.get)
                        : loopInside(element, cfg.get)
                    : element;
                if (cfg.uniqueDB.length === 0 ||
                    dbString.indexOf(JSON.stringify(element)) < 0) {
                    entity = element;
                    break;
                }
            }
            if (entity === null) {
                throw "Can\u00B4t get unique data. Source \"".concat(cfg.hasOne, "\" has not enough data");
            }
        }
        else {
            var i = Math.floor(db[cfg.hasOne].length * Math.random());
            entity = db[cfg.hasOne][i];
            entity = cfg.get
                ? cfg.eval
                    ? eval('entity.' + cfg.get)
                    : loopInside(entity, cfg.get)
                : entity;
        }
        return entity;
    };
    Generator.prototype.hasMany = function (cfg) {
        var _this = this;
        var amount = 1;
        var db = this.DB;
        var min = cfg.min || cfg.min === 0 ? cfg.min : 1;
        var max = cfg.max ? cfg.max : cfg.hasMany ? db[cfg.hasMany].length : 1;
        if (cfg.amount) {
            amount = cfg.amount;
        }
        else {
            amount = Math.floor(Math.random() * (max - min + 1)) + min;
        }
        var newCfg = {
            hasOne: cfg.hasMany,
            get: cfg.get ? cfg.get : undefined,
            eval: cfg.eval ? true : false
        };
        return cfg.unique
            ? Array.from(new Array(amount)).reduce(function (acc, val) { return __spreadArray(__spreadArray([], acc, true), [
                _this.hasOne(__assign(__assign({}, newCfg), { uniqueDB: acc }))
            ], false); }, [])
            : Array.from(new Array(amount)).map(function () { return _this.hasOne(newCfg); });
    };
    return Generator;
}());
export { Generator };
